rules_version = '2';
service cloud.firestore {
  match /databases/{db}/documents {
    function prefix() {
  		return /databases/$(db)/documents;
    }
  
    match /{document=**} { // Access to all resources are blocked by default
      allow read, write: if false;
    }
    
    function numbFacultiesIsLessThan20() {
    	let snapshot = get(/$(prefix())/aggregate/numbFaculties);
    	return request.method == 'update' || snapshot == null || snapshot.data.value < 20;
    }
    function resourceIsValidFaculty() { // check faculty payload on create and update
      let facultyName = request.resource.data.name;
      return facultyName is string &&
      facultyName.matches('^([a-z]+\\s)*[a-z]+$') &&
      facultyName.size() >= 3 &&
      facultyName.size() <= 50 &&
      !exists(/$(prefix())/uniqueFacNames/$(facultyName))
    }
    match /faculties/{facultyId} {
      allow read, delete: if isLoggedIn();
      allow create, update: if isLoggedIn() && fieldsExist(['name'], []) && resourceIsValidFaculty() 
      && numbFacultiesIsLessThan20();
      
      match /sysusers/{userId} {
      	allow read, write: if isLoggedIn();
      }
      
       match /members/{userId} {
      	allow read, write: if isLoggedIn();
      }
    }
    
    match /repos/{repoId} {
    	allow read: if isLoggedIn();
    	allow write: if isLoggedIn();
      
      match /dropboxes/{dropboxId} {
      	allow read, write: if isLoggedIn();
      }
    }
  }
}

// @required: an array of fields that must be included in the incoming doc
// @optional: an array of fields that are optional in the incoming doc
function fieldsExist(required, optional) {
  let allAllowedFields = required.concat(optional);
  return request.resource.data.keys().hasOnly(allAllowedFields) &&
  request.resource.data.keys().hasAll(required);
}

function isLoggedIn() {
  return request.auth != null;
}